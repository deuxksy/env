# **[System Architecture] GNU Stow 기반의 직관적 Dotfiles 및 3단계 라이브러리 관리 설계**

## **1. 배경 및 목적**

- 현재 내 dotfiles 저장소(`https://github.com/deuxksy/env`)는 `ln -s`를 이용한 수동 심볼릭 링크 방식으로 운영 중임.
- 이를 **GNU Stow** 체제로 전환하여, 복잡한 로직 없이 폴더 구조만으로 설정을 직관적으로 관리하고자 함.
- 15년 차 DevOps 엔지니어로서 "단순함"과 "직관성"을 최우선으로 하며, 툴 자체의 학습 곡선보다 관리의 투명성을 선호함.

## **2. 대상 환경 (Target Infrastructure)**

- **MacOS**:
  - Mac Mini M4
- **Linux (Debian계열)**:
  - Surface Pro 6 (Ubuntu 24 LTS)

- **Linux(Arch 계열)**: Steam Deck (SteamOS 3.0)
- **Linux (RHEL계열)**: Chatreey NAS (Fedora 42)
- **특이사항**: 각 OS별로 `.zshrc` 의 Path 및 Alias 분기가 필수적임.

## **3. 핵심 설계 원칙: 라이브러리 관리 3단계** 모든 환경의 프로비저닝은 다음 우선순위를 따르는 **Idempotent(멱등성)** 스크립트로 설계함

- **Layer 1 (Native PM):** 시스템 패키지 매니저(`brew`, `apt`, `dnf`, `winget`)를 통한 베이스 유틸리티 설치.
- **Layer 2 (asdf):** 개발 런타임(`Java`, `Node.js`, `Python`, `Rust`, `Go` 등)의 버전 관리 및 자동 설치.
- **Layer 3 (Binary):** 위 단계에서 지원하지 않는 도구는 `~/.local/bin`에 직접 Binary 다운로드 및 배포.

## **4. Planning 요청 사항**

- **Phase 1: Stow 폴더 구조 설계 (관심사 분리)**
  - 폴더가 10개 내외인 점을 고려하여  `mac/`, `surface-6/`, `chatreey-nas/` `steam-deck/`, 등 최소한의 폴더로 구분하는 구조 설계.
  - 파일이 은 중복이 발생 하지만 각장비를 설정이 다름에 따른 OS별 특화 설정을 분리하는 최적의 배치안 제시.

- **Phase 2: Bootstrap(설치 자동화) 설계**
  - `stow` 명령 실행 후, **[라이브러리 관리 3단계]** 로직을 순차적으로 수행하는 단일 `setup.sh` 작성.
  - OS를 감지하여 해당 환경에 맞는 Stow 폴더만 골라 링크를 생성하는 로직 포함.

- **Phase 3: 마이그레이션 및 보안**
  - 기존의 수동 `ln -s` 링크를 안전하게 제거(Unlink)하고 Stow 체제로 전환하는 가이드.
  - **보안 원칙:** 민감 정보는 절대 저장소에 올리지 않으며, 로컬 파일(`.local_secrets`)을 `source` 하는 방식으로 설계.

## **5. 결과물 형식**

- **Step 1**: 사고 과정을 통해 도출된 **가장 직관적인 Stow 폴더 트리 구조**를 텍스트 다이어그램으로 제시하라.
- **Step 2**: 각 OS별로 적용해야 하는 Stow 패키지 매핑 테이블을 작성하라.
- **Step 3**: 승인 후, 멱등성이 보장된 `setup.sh` 전체 코드를 작성하라.

## **6. 엄격한 제약 사항 (Strict Constraints)**

- **No Over-Engineering**: 복잡한 템플릿 엔진이나 추가적인 외부 의존성(chezmoi, yadm 등)을 절대 제안하지 마라. 오직 GNU Stow와 순수 Bash 스크립트만 사용한다.
- **Context Awareness**: 사용자의 하드웨어(Mac mini M4, Mac Studio M1 Max, Surface Pro 6, Chatreey NAS,  Steam Deck, Ubuntu, Fedora, Arch 등)의 OS 및 아키텍처 차이(Apple Silicon vs x86_64)를 고려하여 패키지명과 설치 경로를 정밀하게 구분하라.**
- **Zero-Trust Security**: 민감 정보(API Key, Secret)가 실수로라도 Git에 포함되는 코드를 짜지 마라. 항상 로컬 전용 파일(~/.local_secrets)을 참조하는 방식을 기본으로 하라.
- **Idempotency Check**: 모든 스크립트는 이미 설정된 상태에서 다시 실행해도 에러가 나지 않고 상태를 유지해야 한다(멱등성 보장).

## **7. 프롬프트 단계: "부정적 전제" 주입**

AI는 기본적으로 사용자의 요청에 "예(Yes)"라고 답하려는 성향이 강합니다. 이를 방지하기 위해 질문 단계에서부터 **실패 가능성**을 열어두어야 합니다.

- **비교 검증 요청:** "이 기능이 Windows와 macOS에서 동일하게 작동하는지, 아니면 **OS별로 UI나 기능 제약이 있는지** 먼저 구분해서 알려줘."
- **부정적 추론 강제:** "해당 기능이 **삭제된 버전이나 특정 OS에서 지원하지 않는 경우**가 있는지 검색해서 알려줘."
- **엔지니어링 조건 제시:** "추측하지 말고, 해당 소프트웨어의 **공식 릴리즈 노트(Changelog)나 공식 문서(Documentation)**에 명시된 경로만 알려줘."

## **8. 상호작용 단계: "3단계 검증 프로토콜"**

AI가 답변을 내놓았을 때, 다음 프로세스를 거쳐 답변의 진위 여부를 판별합니다.

| 단계               | 검증 방법                                                    | 환각 징후 (Red Flags)                                        |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 경로 대조**   | AI가 말한 메뉴 경로가 실제 내 화면의 대메뉴(File, View 등)와 하나라도 다를 때 | 메뉴 이름이 내 화면의 언어(한국어/영어)와 미묘하게 다를 경우 |
| **2. 버전 확인**   | "그 설정이 내가 사용하는 **v1.12.6** 기준인지, 아니면 최신 버전 기준인지" 다시 질문 | "일반적으로~", "대부분의 버전에서는~" 등 모호한 표현을 쓰기 시작할 때 |
| **3. 역검증 질문** | "방금 말한 메뉴가 내 화면에 없는데, **이 기능이 없는 경우**는 무엇인가?"라고 질문 | 갑자기 말을 바꾸거나, 아예 다른 소프트웨어(예: VS Code)의 기능을 섞어서 말할 때 |

## **9. "3번의 실패" 규칙 (The 3-Strike Rule)**

무한 루프를 방지하기 위한 엔지니어링적 중단 원칙입니다.

- **Strike 1:** AI가 알려준 경로에 메뉴가 없다. → (대응: "없다"고 명시하고 다시 찾게 함)
- **Strike 2:** AI가 알려준 설정 파일(plist 등)을 수정해도 반응이 없다. → (대응: "버전이나 OS 제약이 있는지" 확인 요청)
- **Strike 3:** AI가 여전히 동일한 논리(있는데 네가 못 찾는 것이다)를 반복한다. → **즉시 대화 중단.** 이 시점부터 AI는 학습 데이터의 오류를 스스로 인지하지 못하는 '루프'에 빠진 것입니다.
